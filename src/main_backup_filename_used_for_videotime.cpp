#include <istream>
#include <fstream>
#include <iostream>


#include "ros/ros.h"
#include "std_msgs/String.h"
#include "csv.h"
#include "geodesy/utm.h"
#include "geodesy/wgs84.h"
#include <rosbag/bag.h>
#include <time.h>
#include <sensor_msgs/NavSatFix.h>
#include <sensor_msgs/Imu.h>
#include <sensor_msgs/Image.h>
#include <tf2/LinearMath/Quaternion.h>
#include <geometry_msgs/Quaternion.h>
#include <tf/transform_datatypes.h>


#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>


#include <sstream>

using namespace std;
using namespace tf;
using namespace cv;

# define M_PI       3.14159265358979323846  /* pi */

/**
 * This tutorial demonstrates simple sending of messages over the ROS system.
 */
int main(int argc, char **argv)
{

    if ( argc != 3 )
    {
    printf("usage: rosrun rospackage rosnode <Full Path + File nameof the log file generated by AitrData.com (e.g., 2016-02-26_21-16-27_Standard.csv)> <Start time of the video (in milliseconds) from the beginning of the log> [hint: For the second argument look into the log details on the Airdata website. Go to a particular log, click on Media, then click on Map. Match that info with the corresponding CSV to find the right millisecond, e.g., in case of 2016-02-26_21-16-27_Standard.csv the timestamp is 85400]\n");
    return -1;            
    }
    
    
    ros::init(argc, argv, "spark_csv_to_bag");

    ros::NodeHandle n;
    int count = 0, count_m = 0;
    
    // Initialize the bag and start writing in it
    rosbag::Bag bag;
    char bagFileName[200];
    sprintf(bagFileName,"%s.bag",argv[1]);
    bag.open(bagFileName, rosbag::bagmode::Write);    
    
    //Initialize messages
    sensor_msgs::NavSatFix gpsPosition;
    sensor_msgs::Imu sparkOrientation;
    sensor_msgs::Imu gimbalOrientation;
    tf::Quaternion sparkQuaternion, gimbalQuaternion;
    geometry_msgs::Quaternion quat_msg, gimbal_quat_msg;       
    ros::Time messageTime;     


    // Initialize the bag file to read
    io::CSVReader<10> in(argv[1]);
    in.read_header(io::ignore_extra_column,
                   "time(millisecond)","datetime(utc)","latitude","longitude","altitude_above_seaLevel(feet)","compass_heading(degrees)","pitch(degrees)","roll(degrees)","gimbal_heading(degrees)","gimbal_pitch(degrees)");
    std::string FlightMode, Time_text; int size; double speed;
    int Id;  int Time_milliSecs;
    double Time_seconds,
    Latitude,Longitude,Altitude_meters,Altitude_feet, 
    pitch,roll,yaw,
    cam_pitch,cam_roll,cam_yaw;
    
    // Initialize time related structs and variables
    //Set up time
    int firstSecStamp;
    time_t rawtime;
    struct tm * timeinfo;
    time_t unix_time,unix_time_base_for_image,unix_time_base_for_data;
    int year,month,day,hour,min,sec,nsec;
    int offsetMilSec;
    long int rosTimeSec = 0;  int rosTimeNsec = 0; 

    //Initialize time related to the first timestamp of the video stream. See the second argument for running this code and its explanation
    int VideoStartMillisecond;
    long int VideoStartTimeStampSec = 0; int VideoStartTimeStampNsec = 0; 
    VideoStartMillisecond = atoi(argv[2]);
    
    // Variables to check first change in second so as toassign the millisecods properly
    bool FirstChangeInSecondOccured = false;
      
    while(in.read_row(Time_milliSecs,Time_text,Latitude,Longitude,Altitude_feet,yaw, 
    pitch,roll,cam_yaw,cam_pitch))
    {
        // do stuff with the data
        //parse the date time example: 2016/02/26 21:16:27.280 
        sscanf(Time_text.c_str(),"%d-%d-%d %d:%d:%d",&year,&month,&day,&hour,&min,&sec);
        //printf("Date time = year %d , month %d, day %d, hour %d , min %d, sec %d, \n",year,month,day,hour,min,sec);
     
        
        if (count_m==0)
        {
            firstSecStamp=sec; 
            offsetMilSec = Time_milliSecs;
            count_m++;
        }
        else
        {
            if(!FirstChangeInSecondOccured)
            {
                if(sec>firstSecStamp)
                {
                    // When first change in the 'second' count happens, we start saving data. Before that it is difficult to match millisecond and actual time. The max we lose is 1 sec of data which is also before takeoff in most cases!
                    FirstChangeInSecondOccured = true;  
            
                    /* get current timeinfo: */
                    time ( &rawtime ); //or: rawtime = time(0);
                    /* convert to struct: */
                    timeinfo = localtime ( &rawtime ); 

                    /* now modify the timeinfo to the given date: */
                    timeinfo->tm_year   = year - 1900;
                    timeinfo->tm_mon    = month - 1;    //months since January - [0,11]
                    timeinfo->tm_mday   = day;          //day of the month - [1,31] 
                    timeinfo->tm_hour   = hour;         //hours since midnight - [0,23]
                    timeinfo->tm_min    = min;          //minutes after the hour - [0,59]
                    timeinfo->tm_sec    = sec;          //seconds after the minute - [0,59]

                    /* call mktime: create unix time stamp from timeinfo struct */
                    unix_time_base_for_data = timegm ( timeinfo );                      
                    offsetMilSec = Time_milliSecs; // this saves the offset which needs to be deducted every time.            
                    printf("Only once this happens\n");
                    printf("Date time = year %d , month %d, day %d, hour %d , min %d, sec %d, \n",year,month,day,hour,min,sec);
                    printf("unix_time_base_for_data = %ld \n",unix_time_base_for_data + ((Time_milliSecs-offsetMilSec)/1000));
                }
            }
            
            if(FirstChangeInSecondOccured)
            {        
                // Use unix_time_base_for_data and add the milliseconds now. We forget the full date-time info from each row since it is redundant now as we have the millisecond info 

                if(count>0)
                rosTimeSec =  (long int) unix_time_base_for_data + (long int) ((Time_milliSecs-offsetMilSec)/1000);
                else
                rosTimeSec =  (long int) unix_time_base_for_data;  
                
                rosTimeNsec =  1000000*((Time_milliSecs-offsetMilSec)%1000); 
                        
                messageTime = ros::Time(rosTimeSec,rosTimeNsec); 
                // Some debug messages.
                //if((count>845 && count <860) || count == 0)
                    //printf("count = %d ... sec = %ld, nsec = %d\n",count,rosTimeSec,rosTimeNsec);
                
                
                //messageTime = ros::Time(unix_time + (int)Time_seconds,  (int)10*(Time_seconds - (int)Time_seconds));
                
                gpsPosition.latitude = Latitude;
                gpsPosition.longitude = Longitude;
                gpsPosition.altitude = Altitude_feet*0.3048;
                
                gpsPosition.header.seq = count;
                gpsPosition.header.stamp = messageTime;
                gpsPosition.header.frame_id = "gps_receiver";
                
                sparkOrientation.header.seq = count;
                sparkOrientation.header.stamp = messageTime;
                sparkOrientation.header.frame_id = "gps_receiver"; 
                
                //setRPY expects angles in radians between -pi to pi.
                if(yaw>180)
                    yaw=yaw-360;
                sparkQuaternion.setRPY(roll*(M_PI/180), -pitch*(M_PI/180), yaw*(M_PI/180)); // Pitch down is negative in the CSV files (DJI Spark's reference frame)
                sparkQuaternion.normalize();
                tf::quaternionTFToMsg(sparkQuaternion, quat_msg);
                sparkOrientation.orientation = quat_msg;
                
                
                gimbalOrientation.header.seq = count;
                gimbalOrientation.header.stamp = messageTime;
                gimbalOrientation.header.frame_id = "camera_frame"; 
                gimbalQuaternion.setRPY(0, -cam_pitch*(M_PI/180), 0); // Pitch down is negative in the CSV files (DJI Spark's reference frame)
                gimbalQuaternion.normalize();
                tf::quaternionTFToMsg(gimbalQuaternion, gimbal_quat_msg);
                gimbalOrientation.orientation = gimbal_quat_msg;        

                
                //make the bag here
                bag.write("/spark_red/gpsPose", messageTime, gpsPosition);
                bag.write("/spark_red/Orientation", messageTime, sparkOrientation);
                bag.write("/spark_red/gimbal/Orientation", messageTime,gimbalOrientation);
                ++count;
            }
        }
    }
    
    //bag.close();


    //return 0;    
    
  
    // File reading the image id and timestamps
    FILE *imageFileLogHandler; long int imageID=0, pts_image=0, image_sec=0, imagensec=0;
    float image_time=0.0;
    imageFileLogHandler = fopen("video_to_images/image_id_timestamp.log","r");
    //fscanf(imageFileLogHandler,"n:%d pts: %d pts_time:%d.%d\n",&imageID,&pts_image,&image_sec,&imagensec);
    
    //Load the base time for the images
    // e.g. 2016_02_26_21_17_51.info
    sscanf(argv[1],"%d_%d_%d_%d_%d_%d.info",&year,&month,&day,&hour,&min,&sec);
    /* get current timeinfo: */
    //time ( &rawtime ); //or: rawtime = time(0);
    /* convert to struct: */
    //timeinfo = localtime ( &rawtime ); 
    /* now modify the timeinfo to the given date: */
    timeinfo->tm_year   = year - 1900;
    timeinfo->tm_mon    = month - 1;    //months since January - [0,11]
    timeinfo->tm_mday   = day;          //day of the month - [1,31] 
    timeinfo->tm_hour   = hour;         //hours since midnight - [0,23]
    timeinfo->tm_min    = min;          //minutes after the hour - [0,59]
    timeinfo->tm_sec    = sec;          //seconds after the minute - [0,59]

    /* call mktime: create unix time stamp from timeinfo struct */
    unix_time_base_for_image = timegm ( timeinfo );  
    ros::Time imageMsgTime;
    
    cv::Mat image;
    std_msgs::Header header;
    char mystring [100];
    char filename[100];    
    
    while(!feof(imageFileLogHandler))
    {
        fgets (mystring , 100 , imageFileLogHandler);
        printf("%s\n",mystring);
        
        if(imageID < 9999)
            sscanf(mystring,"n:%4ld pts:%7ld pts_time:%f\n",&imageID,&pts_image,&image_time);
        else
            sscanf(mystring,"n:%5ld pts:%7ld pts_time:%f\n",&imageID,&pts_image,&image_time);
        
        imageMsgTime = ros::Time(unix_time_base_for_image+(int)image_time, 1000000000*(image_time-(int)image_time));
        
        //Create image message
        
        //Create image filename, e.g., fr00001.jpg

        sprintf(filename,"video_to_images/images/fr%05ld.jpg",imageID);

        
        printf("image file is %s\n",filename);
        
        header.stamp = imageMsgTime;
        header.frame_id = "spark_cam_image";
        header.seq = imageID;
        image = cv::imread(filename, CV_LOAD_IMAGE_COLOR);
        sensor_msgs::ImagePtr img_msg = cv_bridge::CvImage(header, "bgr8", image).toImageMsg();        
  
        bag.write ("/spark_red/image_raw", imageMsgTime, img_msg);        
        printf("processed file fr%ld.jpg AT pts_image = %ld time = %ld.%f\n",imageID,pts_image,unix_time_base_for_image+(int)image_time,1000000000*(image_time-(int)image_time));
    }


    bag.close();


    return 0;
}
